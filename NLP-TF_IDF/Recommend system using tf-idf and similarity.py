# -*- coding: utf-8 -*-
"""TF_IDF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lMzsX__tNYl7cGYGuhgUh3r7oDO3QWaj

불용어 리스트
"""

conjunct=['그리고', '게다가', '더욱이', '더구나', '아울러', '뿐만', '뿐만 아니라', '어쩌면',
          '그러나', '하지만', '그렇지만', '그럼에도', '반면에', '도리어', '오히려', 
          '그러므로', '따라서', '그러니까', '그리하여', '그렇게', '때문에', '그래서',
          '그러면', '그러니', '마침내', '왜냐하면', '그런데', '즉', '말하자면', '사실상',
          '예컨데', '끝으로', '결국', '결론적으로', '마지막으로', '정말', '너무', '엄청', '많이', '싶은']
post=['이', '가', '이다', '을', '를', '의', '에', '에서', '로', '와', '과', '보다', '아', '야', 
      '랑', '며', '이랑', '이며', '나', '은', '는', '만', '밖에', '뿐', '도', '조차', '마저',
      '까지', '이나', '든지', '이든지', '나마', '이나마', '라도', '이라도']

pip install nltk

import nltk
nltk.download('punkt')

"""불용어 제거 자체 알고리즘 테스트"""

from nltk.tokenize import word_tokenize
from nltk.tokenize import sent_tokenize
test='그런데 저는 과일이 너무 좋습니다. 하지만 나는 야채는 정말 싫어합니다.'
test=test.replace(".", "")
tokens=word_tokenize(test)
process=[]
for t in tokens:
  if t in conjunct:
    continue
  else:
    if t[len(t)-1] in post:
      t=t.rstrip(t[len(t)-1])
      process.append(t)
    else:
      process.append(t)
aftertest=" ".join(process)
print(aftertest)

"""konlpy 활용 조사/접속사 제거 알고리즘"""

pip install konlpy

import konlpy.tag
docs = [
  '그런데 먹고 싶은 사과',
  '먹고 싶은 바나나',
  '길고 노란 바나나 바나나',
  '저는 과일이 좋아요',
  '먹고 싶은 사과',
  '사과는 영어로 apple 입니다'
] 
after_docs=[]
for now in docs:
  Okt=konlpy.tag.Okt()
  Okt_morphs=Okt.pos(now)
  temp=[]
  for word, pos in Okt_morphs:
    if pos=="Josa" or pos=="Conjunction" or pos=="Adjective":
      continue
    else:
      temp.append(word)
  newsent=" ".join(temp)
  after_docs.append(newsent)
print(after_docs)

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer

"""DTM 생성"""

vector=CountVectorizer()
dtm=vector.fit_transform(after_docs).toarray()
print(dtm)
print(vector.vocabulary_)

"""TF-IDF 생성"""

tfidfv=TfidfVectorizer().fit(after_docs)
tfidf=tfidfv.transform(after_docs).toarray()
print(tfidf)
print(tfidfv.vocabulary_)

"""코사인 유사도"""

from numpy import dot
from numpy.linalg import norm
import numpy as np
def cos_sim(A, B):
       return dot(A, B)/(norm(A)*norm(B))

print(cos_sim(tfidf[0], tfidf[1]))
print(cos_sim(tfidf[0], tfidf[2]))
print(cos_sim(tfidf[1], tfidf[2]))
print(cos_sim(tfidf[0], tfidf[4]))

from sklearn.metrics.pairwise import linear_kernel
cosine_sim=linear_kernel(tfidf, tfidf)
print(cosine_sim)

"""추천 시스템 만들기-사용자가 선택하는 키워드가 아닌, 자체적으로 TF-IDF와 코사인 유사도를 통해서 나오는 유사도를 통해서 유사 텍스트를 추천하는 시스템

현재 사용자가 입력한 텍스트에서 조사, 접속사, 형용사 부분을 konlpy를 통해서 없애는 작업
"""

want="내가 먹고 싶은 것은 바나나 입니다. 바나나 좋아요"
want=want.replace(".", "")
Okt=konlpy.tag.Okt()
Okt_morphs=Okt.pos(want)
print(Okt_morphs)
tmp=[]
for word, pos in Okt_morphs:
  if pos=="Josa" or pos=="Conjunction" or pos=="Adjective":
    continue
  else:
    tmp.append(word)
after_want=" ".join(tmp)
print(after_want)

"""시스템상에 이미 가지고 있는 텍스트와 내가 알아보고자 하는 텍스트 사이의 유사도를 TF-IDF와 코사인 유사도를 통해 측정"""

now_docs=after_docs
now_docs.append(after_want)
tfidfv_recommend=TfidfVectorizer().fit(after_docs)
tfidf_recommend=tfidfv_recommend.transform(after_docs).toarray()
print(tfidf_recommend)
print(tfidfv_recommend.vocabulary_)
cosine_recommend=linear_kernel(tfidf_recommend, tfidf_recommend)
print(cosine_recommend)

"""현재 텍스트와 코사인 유사도가 가장 높은 순으로 정렬"""

recommend_percent=cosine_recommend[len(cosine_recommend)-1]
recommend=np.argsort(-recommend_percent)
print(now_docs)
for i in range(len(now_docs)):
  if after_want==now_docs[recommend[i]]:
    continue
  print(now_docs[recommend[i]], recommend_percent[recommend[i]]*100)

"""선택 키워드 기반 추천 시스템-각각의 키워드를 뽑아내고 사용자가 선택한 키워드 기반으로 추천하는 시스템

시스템 상에 존재하는 텍스트의 키워드를 뽑아내고 그 키워드만으로 이루어진 텍스트로 재저장
"""

wordlist=tfidfv.vocabulary_
wordlist=dict(zip(wordlist.values(),wordlist.keys()))
#total words
each_words=[]
each_words_percent=[]
keyword_text=[]
for i in range(len(tfidf)):
  now=tfidf[i]
  keyword_idx=np.argsort(-tfidf[i])
  words=[]
  percent=[]
  for j in range(len(keyword_idx)):
    if now[keyword_idx[j]]==0:
      break
    percent.append(now[keyword_idx[j]]*100)
    words.append(wordlist[keyword_idx[j]])
  keyword_text.append(" ".join(words))
  each_words.append(words)
  each_words_percent.append(percent)
print(keyword_text)
#keyword_text is the text that only contains keywords
for i in range(len(each_words)):
  print(each_words[i])
  print(each_words_percent[i])
#keywords of total text
#have to work and store before user using keyword system

"""사용자가 고른 텍스트의 키워드를 뽑아내고 그 키워드만으로 이루어진 텍스트로 재저장"""

now_keyword=tfidf_recommend[len(tfidf_recommend)-1]
keyword_idx=np.argsort(-now_keyword)
now_keyword_text=[]
for i in range(7):
  if now_keyword[keyword_idx[i]]*100==0:
    break
  print(wordlist[keyword_idx[i]], now_keyword[keyword_idx[i]]*100)
  now_keyword_text.append(wordlist[keyword_idx[i]])
now_keyword_text=" ".join(now_keyword_text)
#now_keyword_text is the text that chosen text but only contains keywords
print(now_keyword_text)
#keywords of text that want

"""위에서 생성한 키워드 텍스트로 다시 TF-IDF와 코사인 유사도 계산"""

total_keyword_text=keyword_text
total_keyword_text.append(now_keyword_text)

tfidfv_keyword=TfidfVectorizer().fit(total_keyword_text)
tfidf_keyword=tfidfv_keyword.transform(total_keyword_text).toarray()
cosine_keyword=linear_kernel(tfidf_keyword, tfidf_keyword)
keyword_percent=cosine_keyword[len(cosine_keyword)-1]
keyword_recommend=np.argsort(-keyword_percent)
for i in range(len(keyword_recommend)):
  if after_want==now_docs[keyword_recommend[i]]:
    continue
  print(now_docs[keyword_recommend[i]], keyword_percent[keyword_recommend[i]]*100)

"""# **<전체 텍스트>**<br>
1) 먹고 싶은 사과<br>
2) 먹고 싶은 바나나<br>
3) 바나나 바나나<br>
4) 저 과일<br>
5) 먹고 싶은 사과<br>
6) 사과 영어 apple<br>
# **<현재 텍스트><br>**
내 먹고 싶은 것 바나나 바나나<br>
# **<단순 추천 시스템 결과><br>**
먹고 싶은 바나나 94.3843093342014<br>
바나나 바나나 85.22166141189456<br>
먹고 싶은 사과 40.56681247880616<br>
먹고 싶은 사과 40.56681247880616<br>
저 과일 0.0<br>
사과 영어 apple 0.0<br><br>
# **<키워드 기반 추천 시스템 결과><br>**
먹고 싶은 바나나 99.99999999999999<br>
바나나 바나나 63.150020738605114<br>
먹고 싶은 사과 60.12074880713742<br>
먹고 싶은 사과 60.12074880713742<br>
저 과일 0.0<br>
사과 영어 apple 0.0<br>
"""